/**
 * ============LICENSE_START====================================================
 * org.onap.aaf
 * ===========================================================================
 * Copyright (c) 2018 AT&T Intellectual Property. All rights reserved.
 * ===========================================================================
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 *      http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============LICENSE_END====================================================
 *
 */

package org.onap.aaf.cadi.configure;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

import org.onap.aaf.cadi.Access;
import org.onap.aaf.cadi.Symm;
import org.onap.aaf.cadi.util.Chmod;
import org.onap.aaf.misc.env.util.Chrono;

import certman.v1_0.Artifacts.Artifact;

// Doing this because there are lots of lists spread out in this model...
    // we want these to be unique.
public class PropHolder {
    private File dir;
    private File file;
    private File keyfile;
    private Symm symm;
    private Map<String,String> props;

    private static boolean dirMessage = true;
    protected final static Map<String,PropHolder> propHolders = new HashMap<>();

    public static PropHolder get(Artifact arti, String suffix) throws IOException {
        File dir = new File(arti.getDir());
        if (dir.exists()) {
            if(dirMessage) {
                System.out.println("Writing to " + dir.getCanonicalFile());
            }
        } else if (dir.mkdirs()) {
            if(dirMessage) {
                System.out.println("Created directory " + dir.getCanonicalFile());
            }
        } else {
            throw new IOException("Unable to create or write to " + dir.getCanonicalPath());
        }
        dirMessage = false;
        File file = new File(dir,arti.getNs()+'.'+suffix);

        PropHolder ph = propHolders.get(file.getAbsolutePath());
        if(ph == null) {
            ph = new PropHolder(dir,file,new File(dir,arti.getNs()+".keyfile"));
            propHolders.put(file.getAbsolutePath(), ph);
        } 
        return ph;
    }

    private PropHolder(File dir, File file, File keyfile) throws IOException {
        this.dir = dir;
        this.file = file;
        this.keyfile = keyfile;
        symm = null;
        props = new TreeMap<>();
    }

    public String getPath() {
        return file.getAbsolutePath();
    }

    public File getDir() {
        return dir;
    }

    public String getKeyPath() {
        return keyfile.getAbsolutePath();
    }

    public String add(final String tag, final String value) {
        final String rv = value==null?"":value;
        props.put(tag, rv);
        return rv;
    }

    public String add(final String tag, Access orig, final String def) {
        return add(tag, orig.getProperty(tag, def));
    }

    public String addEnc(final String tag, final String value) throws IOException {
        String rv;
        if(value==null) {
            rv = "";
        } else {
            if(symm==null) { // Lazy Instantiations... on a few PropFiles have Security
                symm = ArtifactDir.getSymm(keyfile);
            }
            rv = "enc:"+symm.enpass(value);
        }
        props.put(tag, rv);
        return rv;
    }

    public void addEnc(final String tag, Access orig, final String def) throws IOException {
        String pwd = orig.getProperty(tag, def);
        if(pwd==null) {
            return;
        } else if(pwd.startsWith("enc:")) {
            pwd = orig.decrypt(pwd, true);
        }
        addEnc(tag,pwd);
    }

    public void write() throws IOException {
        if (props.size()==0) {
            return;
        }

        if (file.exists()) {
            System.out.println("Backing up " + file.getCanonicalPath());
            File backup = File.createTempFile(file.getName()+'.', ".backup",dir);
            file.renameTo(backup);
        } else {
            System.out.println("Creating new " + file.getCanonicalPath());
        }
    
        // Append if not first
        PrintWriter pw = new PrintWriter(new FileWriter(file));
        try {
            // Write a Header
            for (int i=0;i<60;++i) {
                pw.print('#');
            }
            pw.println();
            pw.println("# Properties Generated by AT&T Certificate Manager");
            pw.print("#   by ");
            pw.println(System.getProperty("user.name"));
            pw.print("#   on ");
            pw.println(Chrono.dateStamp());
            pw.println("# @copyright 2019, AT&T");
            for (int i=0;i<60;++i) {
                pw.print('#');
            }
            pw.println();
        
             for (Map.Entry<String,String> me : props.entrySet()) {
                String key = me.getKey();
                    pw.print(key);
                    pw.print('=');
                    pw.println(me.getValue());
            }
        } finally {
            pw.close();
        }
        Chmod.to644.chmod(file);
    }

    public static void writeAll() throws IOException {
        for(PropHolder ph : propHolders.values()) {
            ph.write();
        }
    }

    @Override
    public String toString() {
        return file.getAbsolutePath() + ": " + props;
    }
}
